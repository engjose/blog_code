{"meta":{"title":"SUPER-JOSE-大叔的技术博客","subtitle":"There is no shortcut is a permanent shortcut","description":"踏踏实实做人,认认真真编程","author":"SUPER-JOSE","url":"http://www.fireworm.online"},"pages":[{"title":"categories","date":"2017-05-21T09:37:55.000Z","updated":"2017-05-21T09:38:27.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.fireworm.online/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-21T09:20:01.000Z","updated":"2017-05-21T09:21:20.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.fireworm.online/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Thinking in Java(一)一切皆对象","slug":"Thinking-in-Java-一-一切皆对象","date":"2017-05-23T15:30:14.000Z","updated":"2017-05-23T15:30:14.000Z","comments":true,"path":"THINKING-IN-JAVA/2017/05/23/Thinking-in-Java-一-一切皆对象.html","link":"","permalink":"http://www.fireworm.online/THINKING-IN-JAVA/2017/05/23/Thinking-in-Java-一-一切皆对象.html","excerpt":"","text":"java的设计尽管java是基于C++开发的,但是java是一个纯粹的面向对象的程序设计语言;C++之所以成为一种杂合行的设计语言,是因为C++支持C语言的向后兼容,但是这种兼容却让C++变得臃肿,java是基于C++而简化了C++中比较臃肿的东西 引用操作对象每种计算机语言都有自己操作内存元素的方式.java是面向对象的,因此java采用一个固定的方式来操作内存中的元素: java中通过引用来操作对象 这就好比遥控器与电视的关系,我们操作的是遥控器,再由遥控器来操作电视 此外,即使没有电视机遥控器也可以独立的存在,也就是说你可以有一个引用,但是不必有对象与其关联 12//创建一个引用,没有对象指定String s; java中的内存模型 寄存器:寄存器是最快的存储区域,因为它位于处理器的内部.我们采用java是无法直接操作寄存器的 堆栈:堆栈是位于RAM(随机访问存储器),堆栈的指针向下移动则分配新的内存,堆栈指针向上移动则释放内存,堆栈的速度仅次于寄存器;我们平时使用的对象的引用就存在于堆栈中 堆:堆内存也位于RAM中,用于存储所有的java对象.当我们需要在堆栈中创建对象的时候只通过new关键字即可,当然这种方便也会带来一些额外的开销:用堆进行内存分配和清理比堆栈慢 常量寄存器:我们的常量一般是存储于代码中的,这样比较安全,我们也可以选择存储在ROM(只读存储器)中 非RAM存储器:如果数据完全存储于代码之外,比如流对象和持久化对象最终会被存储在磁盘或者其他的地方,这样反序列化的时候就会再次找到 基本数据类型的存储java中并不是所有的变量都是通过new来进行创建的,我们对于比较小的常用的数据类型不使用new关键字创建,而是创建一个并非引用的’自动’变量,将这个变量的值直接存储于堆栈中,这样提高了数据存储额效率 基本数据类型java中基本数据类型的大小都是固定的,这也是java夸平台原因之一 基本类型 大小 boolean - byte 1 short 2 int 4 long 8 float 4 double 8 所有的数值类型都具有正负号,不要去寻求无符号的数值类型,boolean占的大小没有指定,但是只能存储true/false 高精度数字java提供了两种高精度的计算:BigInteger和BigDecimal,能用基本数据类型操作的都可以用包装类型进行操作,但是需要调用方法.这么做复杂了许多,当然运算速度也慢了许多,这里是利用速度换取了精度 BigInteger支持任意精度的整数运算 BigDecimal支持任意精度的浮点型运算 类的描述我们知道java是面相对象的,并且知道用new关键字来创建对象.但是如何在开发中创建我们自定义类和对象的呢?其实类由两部分组成:成员方法和成员变量,成员变量描述类所具备的属性,成员方法说明了该类具有哪些功能 成员变量定义我们在类中定义了成员变量默认都会初始化的,但是局部变量不会默认进行初始化,所以我们在使用局部变量之前一定先给其初始化才行,负责编译器就会报错.以下是我们成员变量的默认初始化: 数据类型 默认值 boolean false char \\u0000 byte (byte)0 short (short)0 int 0 long 0L float 0.0F double 0.0 static关键字出现需求: 为某个特定的区域分配单一存储空间,而不需要考虑需要多少个对象 希望被static修饰的不与任何的对象所关联,只与当前的类相关 下面这段代码无论有多少个StaticTest对象StaticTest.i只会有一份存储空间,N个对象共享一个i.123calss StaticTest &#123; static int i = 47;&#125; 建议:在静态使用中,建议使用类直接调用,而不建议使用创建对象的方式,因为这样表现层次更加的明确,说明静态是属于类的,而并非对象的.","categories":[{"name":"THINKING IN JAVA","slug":"THINKING-IN-JAVA","permalink":"http://www.fireworm.online/categories/THINKING-IN-JAVA/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.fireworm.online/tags/读书笔记/"}]},{"title":"join链接查询","slug":"join链接查询","date":"2017-05-21T11:27:58.000Z","updated":"2017-05-21T11:27:58.000Z","comments":true,"path":"mysql/2017/05/21/join链接查询.html","link":"","permalink":"http://www.fireworm.online/mysql/2017/05/21/join链接查询.html","excerpt":"","text":"数据表结构表结构一:表结构二: Join从句的分类 Inner joininner join表示将两张表进行关联起来,查询里面的交集部分1SELECT * FROM user1 INNER JOIN user2 WHERE user1.username = user2.name; 查询结果:当查询*的时候是将两张表进行拼接起来 左外链接用途左外链接一般查询的是左表的所有和右表所匹配的数据,匹配不上的全是null1SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name 查询结果:查询只存在于左表中的数据1SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name WHERE user2.name IS NOT NULL 查询结果: 右外链接右外链接和左外链接是相对的,只不过是以右表为基准 全连接全连接表示可以查询出两个表所有的数据或两个表交集之外的数据代码演示:1SELECT * FROM user1 LEFT JOIN user2 ON user1.username = user2.name UNION ALL SELECT * FROM user1 RIGHT JOIN user2 ON user1.username = user2.name 查询结果:","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.fireworm.online/categories/mysql/"}],"tags":[{"name":"链接查询","slug":"链接查询","permalink":"http://www.fireworm.online/tags/链接查询/"}]},{"title":"mysql数据类型","slug":"mysql数据类型","date":"2017-05-21T08:55:47.000Z","updated":"2017-05-21T08:55:47.000Z","comments":true,"path":"mysql/2017/05/21/mysql数据类型.html","link":"","permalink":"http://www.fireworm.online/mysql/2017/05/21/mysql数据类型.html","excerpt":"","text":"mysql数据类型以及语句分类跟学习java一样,我们在学习mysql之前需要理解mysql中的数据类型,接下来就介绍一下mysql中的几种数据类型,具体的使用哪种数据类型还需要根据当时的场景来定义 整型 浮点型 字符型 时间类型 mysql的语句分类","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.fireworm.online/categories/mysql/"}],"tags":[{"name":"mysql基础","slug":"mysql基础","permalink":"http://www.fireworm.online/tags/mysql基础/"}]},{"title":"数组常用API","slug":"数组常用API","date":"2017-05-21T07:01:11.000Z","updated":"2017-05-21T07:01:11.000Z","comments":true,"path":"javaSE/2017/05/21/数组常用API.html","link":"","permalink":"http://www.fireworm.online/javaSE/2017/05/21/数组常用API.html","excerpt":"","text":"数组注意事项对于数组的定义和一般使用技巧,我们肯定都是比较熟悉了.这里主要介绍一下数据的一些好用API以及注意事项 数组的基本使用—创建数组 当创建一个数字型的数组时,所有元素都初始化为0 当创建boolean类型的数组时,所有元素都初始化为false 当创建一个对象数组时,所有元素都初始化为null,例如:12//创建一个包含十个字符串的数组,但是每一个的初始化字符串都是nullString[] str = new String[10] 数组工具类常用API—Arraysstatic T[] copyOf(T[] original, int newLength) —将original数组拷贝newLength个到一个新的数组中,方法的返回值是一个新的数组 static void sort(type[] a)—将数组进行排序,使用的是快排,效率比较高 static int binarySearch(type[] a, type key)—在数组a中进行二分查找key,如果查找成功则返回下标值,否则返回一个负数 static void fill(type[] a, type v)—将数组的所有数据元素赋值为v boolean equals(type[] a, type[] b)—如果两个数组大小相同,并且下标相同的元素都相同返回true,否则返回false","categories":[{"name":"javaSE","slug":"javaSE","permalink":"http://www.fireworm.online/categories/javaSE/"}],"tags":[{"name":"集合体系","slug":"集合体系","permalink":"http://www.fireworm.online/tags/集合体系/"}]},{"title":"BigDecimal","slug":"BigDecimal","date":"2017-05-21T04:00:33.000Z","updated":"2017-05-21T04:00:33.000Z","comments":true,"path":"javaSE/2017/05/21/BigDecimal.html","link":"","permalink":"http://www.fireworm.online/javaSE/2017/05/21/BigDecimal.html","excerpt":"","text":"大数据类型BigDecimal与Double我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal. BigDecimal与Double的实验分别采用两种方式计算两个小数的加法运算:1234567891011public static void testNaN() &#123; int num1 = 10; float num2 = 10.1F; double num3 = 10.2; BigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2)); BigDecimal add2 = new BigDecimal(\"10.1\").add(new BigDecimal(\"10.2\")); BigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3)); Double add4 = num3 + num2; System.out.println(add1 + \"****\" + add2 + \"****\" + add3 + \"****\" + add4);&#125; 执行结果120.3****20.3****20.300000381469727****20.300000381469726 得出结论浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性 使用心得我们在使用BigDecimal的时候应该采用构造方法,传入字符串的形式进行加减乘除计算 API的使用add(other) — 和 subtract(other) — 差 multiply(other) — 积 divid(other) — 商 mod(oher) — 余 int compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数 valueOf(other) — 将基数值转换为大数据类型","categories":[{"name":"javaSE","slug":"javaSE","permalink":"http://www.fireworm.online/categories/javaSE/"}],"tags":[{"name":"BigDecimal数据类型","slug":"BigDecimal数据类型","permalink":"http://www.fireworm.online/tags/BigDecimal数据类型/"}]},{"title":"List集合切割工具类","slug":"List集合切割工具类","date":"2017-05-15T14:55:00.000Z","updated":"2017-05-15T14:55:00.000Z","comments":true,"path":"工具类/2017/05/15/List集合切割工具类.html","link":"","permalink":"http://www.fireworm.online/工具类/2017/05/15/List集合切割工具类.html","excerpt":"","text":"问题背景我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程 代码实现1234567891011121314151617181920212223242526272829/** * 切割List集合,将其分成等分的 * * @param source * @param pageSize * @return */public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; source, Integer pageSize) &#123; if (null == source || source.size() == 0) &#123; return null; &#125; int size = source.size(); int num = size / pageSize + 1; // 切割list集合 List&lt;List&lt;T&gt;&gt; target = new ArrayList&lt;List&lt;T&gt;&gt;(); List&lt;T&gt; subList = null; for (int i = 0; i &lt; num; i++) &#123; int from = i * pageSize; //如果不是最后一个集合 if (i != num - 1) &#123; subList = source.subList(from, from + pageSize); &#125; else &#123; subList = source.subList(from, from + size % pageSize); &#125; target.add(subList); &#125; return target;&#125; 代码理解 num:表示大集合将要被切割的个数 pageSize表示每个小集合的size subList = source.subList(from, from + pageSize):如果不是最后一个集合,我们需要切割from 到from + pageSize个 subList = source.subList(from, from + size % pageSize): 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize) 功能测试12345678910111213public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.add(5); list.add(6); List&lt;List&lt;Integer&gt;&gt; splitList = splitList(list, 2); System.out.println(splitList);&#125; 测试运行结果[[1, 2], [3, 4], [5, 5], [6]]","categories":[{"name":"工具类","slug":"工具类","permalink":"http://www.fireworm.online/categories/工具类/"}],"tags":[{"name":"集合体系","slug":"集合体系","permalink":"http://www.fireworm.online/tags/集合体系/"}]}]}